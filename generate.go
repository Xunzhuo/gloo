package main

import (
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/ghodss/yaml"
	"github.com/rotisserie/eris"
	"github.com/solo-io/go-utils/log"
	code_generator "github.com/solo-io/solo-kit/pkg/code-generator"
	"github.com/solo-io/solo-kit/pkg/code-generator/cmd"
	"github.com/solo-io/solo-kit/pkg/code-generator/docgen/options"
	"github.com/solo-io/solo-kit/pkg/code-generator/schemagen"
	"github.com/solo-io/solo-kit/pkg/code-generator/schemagen/v1beta1"
	"github.com/solo-io/solo-kit/pkg/code-generator/sk_anyvendor"
	"github.com/solo-io/solo-kit/pkg/code-generator/writer"
	apiextv1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
)

//go:generate go run generate.go
func main() {
	log.Printf("starting generate")

	crdGenerator := NewCRDGenerator()
	validationSchemaOptions, err := crdGenerator.GetValidationSchemaOptions()
	if err != nil {
		log.Fatalf("could not get crd validation schema options! :%v", err)
	}

	protoImports := sk_anyvendor.CreateDefaultMatchOptions(
		[]string{"projects/**/*.proto", sk_anyvendor.SoloKitMatchPattern},
	)
	protoImports.External["github.com/solo-io/solo-apis"] = []string{
		"api/rate-limiter/**/*.proto", // Import rate limit API
		"api/gloo-fed/fed/**/*.proto", // Import gloo fed gloo instance API
	}
	// Import gloo instance API dependencies
	protoImports.External["github.com/solo-io/skv2"] = []string{
		"api/**/**/*.proto",
	}

	generateOptions := cmd.GenerateOptions{
		SkipGenMocks: true,
		CustomCompileProtos: []string{
			"github.com/solo-io/gloo/projects/gloo/api/grpc",
		},
		SkipGeneratedTests: true,
		// helps to cut down on time spent searching for imports, not strictly necessary
		SkipDirs: []string{
			"docs",
			"test",
			"projects/gloo/api/grpc",
		},
		RelativeRoot:  ".",
		CompileProtos: true,
		GenDocs: &cmd.DocsOptions{
			Output: options.Hugo,
			HugoOptions: &options.HugoOptions{
				DataDir: "/docs/data",
				ApiDir:  "reference/api",
			},
		},
		ExternalImports:      protoImports,
		ValidationSchemaOpts: validationSchemaOptions,
	}

	if err := cmd.Generate(generateOptions); err != nil {
		log.Fatalf("generate failed!: %v", err)
	}

	if err := crdGenerator.GenerateCRDs(); err != nil {
		log.Fatalf("crd generate failed! :%v", err)
	}

	log.Printf("finished generating code")
}

const helm2CrdDirectory = "./install/helm/gloo/crds"
const helm3CrdDirectory = "./install/helm/gloo/templates"
const helm3CrdFilename  = "100-crds.yaml"
const fileHeader = `// Code generated by solo-kit. DO NOT EDIT.`
var projectConfigurations = []ProjectCRDConfig{
	{
		GroupId: "gateway.solo.io",
		Filenames: []string{
			"gateway.yaml",
			"virtual_service.yaml",
			//"virtual_service_test.yaml",
			"route_table.yaml",
		},
		GenerationTimeout: time.Minute * 15, // This is a long running operation!
	},
	{
		GroupId: "gloo.solo.io",
		Filenames: []string{
			"upstream.yaml",
			"upstream_group.yaml",
			"settings.yaml",
			"proxy.yaml",
		},
		SkipGeneration: true, // TODO (sam-heilbron) disable this
		GenerationTimeout: time.Minute * 7,
	},
	{
		GroupId: "enterprise.gloo.solo.io",
		Filenames: []string{
			"auth_config.yaml",
		},
		SkipGeneration: true,// TODO (sam-heilbron) disable this
		GenerationTimeout: time.Minute,
	},
	{
		GroupId: "ratelimit.solo.io",
		Filenames: []string{
			"ratelimit_config.yaml",
		},
		SkipGeneration: true,// TODO (sam-heilbron) disable this
		GenerationTimeout: time.Minute,
	},
}

func NewCRDGenerator() *CRDGenerator {
	return &CRDGenerator{
		helm2CrdDirectory:    helm2CrdDirectory,
		helm3CrdDirectory:    helm3CrdDirectory,
		helm3CrdFilename:     helm3CrdFilename,
		projectConfigurations: projectConfigurations,
		crdsWithSchemaByFile: map[string]apiextv1beta1.CustomResourceDefinition{},
	}
}

// TODO (sam-heilbron)
// Until this feature is validated, write to a temp file location
func tempFileName(filename string) string {
	fileExt := filepath.Ext(filename)
	return fmt.Sprintf("%s.gen%s", strings.TrimSuffix(filename, fileExt), fileExt)
}

type ProjectCRDConfig struct {
	GroupId string
	SkipGeneration bool
	GenerationTimeout time.Duration
	Filenames []string
}

type CRDGenerator struct {
	// The directory containing helm2 CRDs
	helm2CrdDirectory string

	// The directory containing helm3 CRDs
	helm3CrdDirectory string

	// The name of the file that contains all CRDs, used by helm3
	helm3CrdFilename  string

	// The configuration per project for schemagen
	projectConfigurations []ProjectCRDConfig

	// The CRDs that we generate during schemagen
	crdsWithSchemaByFile map[string]apiextv1beta1.CustomResourceDefinition
}

func (g *CRDGenerator) GetValidationSchemaOptions() (*schemagen.ValidationSchemaOptions, error) {
	projectSchemaOptions := make(map[string]*schemagen.ProjectValidationSchemaOptions, len(g.projectConfigurations))

	for _, projectConfig := range g.projectConfigurations {
		schemaOptions, err := g.getProjectValidationSchemaOptions(projectConfig)
		if err != nil {
			return nil, err
		}
		projectSchemaOptions[projectConfig.GroupId] = schemaOptions
	}

	return &schemagen.ValidationSchemaOptions{
		ProjectSchemaOptions: projectSchemaOptions,
	}, nil
}

func (g *CRDGenerator) getProjectValidationSchemaOptions(projectConfig ProjectCRDConfig) (*schemagen.ProjectValidationSchemaOptions, error) {
	var schemaOptions []*v1beta1.SchemaOptions

	for _, fileName := range projectConfig.Filenames {
		// Ensure that OnSchemaComplete closure is called with the appropriate file name
		crdFileName := fileName

		crd, err := v1beta1.GetCRDFromFile(filepath.Join(g.helm2CrdDirectory, crdFileName))
		if err != nil {
			return nil, err
		}

		schemaOptions = append(schemaOptions, &v1beta1.SchemaOptions{
			OriginalCrd: crd,
			OnSchemaComplete: func(crdWithSchema apiextv1beta1.CustomResourceDefinition) error {
				g.crdsWithSchemaByFile[crdFileName] = crdWithSchema
				return nil
			},
		})
	}

	return &schemagen.ProjectValidationSchemaOptions{
		SkipGeneration:          projectConfig.SkipGeneration,
		GenerationTimeout:       projectConfig.GenerationTimeout,
		SchemaGenerationOptions: schemaOptions,
	}, nil

}

func (g *CRDGenerator) GenerateCRDs() error {
	if err := g.writeHelm2CRDs(); err != nil {
		return err
	}
	return g.writeHelm3CRDs()
}

func (g *CRDGenerator) writeHelm2CRDs() error {
	crdWriter := writer.DefaultFileWriter{
		Root:   g.helm2CrdDirectory,
		Header: fileHeader,
	}

	var crdFiles code_generator.Files
	for _, projectConfig := range g.projectConfigurations {
		if projectConfig.SkipGeneration {
			continue
		}
		for _, fileName := range projectConfig.Filenames {
			crdWithSchema, ok := g.crdsWithSchemaByFile[fileName]
			if !ok {
				return eris.Errorf("Could not find crd for file: %s", fileName)
			}

			fileBytes, err := yaml.Marshal(crdWithSchema)
			if err != nil {
				return err
			}

			crdFiles = append(crdFiles, code_generator.File{
				Filename: tempFileName(fileName), // TODO (sam-heilbron)
				Content:  string(fileBytes),
			})
		}
	}
	return crdWriter.WriteFiles(crdFiles)
}

func (g *CRDGenerator) writeHelm3CRDs() error {
	crdWriter := writer.DefaultFileWriter{
		Root:   g.helm3CrdDirectory,
		Header: fileHeader,
	}

	// Use helm2 files as the source of truth.
	// This ensures that helm2 and helm3 stay in lockstep

	var manifests []string
	for _, projectConfig := range g.projectConfigurations {
		for _, fileName := range projectConfig.Filenames {
			helm2Crd, err := v1beta1.GetCRDFromFile(filepath.Join(g.helm2CrdDirectory, fileName))
			if err != nil {
				return err
			}

			fileBytes, err := yaml.Marshal(helm2Crd)
			if err != nil {
				return err
			}
			manifests = append(manifests, string(fileBytes))
		}
	}

	fileContent := fmt.Sprintf(
		"%s%s%s",
		"{{- if .Values.crds.create }}\n",
		strings.Join(manifests, "---\n"),
		"---\n{{- end}}")

	helm3CrdFile := code_generator.File{
		Filename: tempFileName(g.helm3CrdFilename), // TODO (sam-heilbron)
		Content:  fileContent,
	}
	return crdWriter.WriteFile(helm3CrdFile)
}
