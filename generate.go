package main

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/ghodss/yaml"
	"github.com/rotisserie/eris"
	"github.com/solo-io/go-utils/log"
	code_generator "github.com/solo-io/solo-kit/pkg/code-generator"
	"github.com/solo-io/solo-kit/pkg/code-generator/cmd"
	"github.com/solo-io/solo-kit/pkg/code-generator/docgen/options"
	"github.com/solo-io/solo-kit/pkg/code-generator/schemagen"
	"github.com/solo-io/solo-kit/pkg/code-generator/schemagen/v1beta1"
	"github.com/solo-io/solo-kit/pkg/code-generator/sk_anyvendor"
	"github.com/solo-io/solo-kit/pkg/code-generator/writer"
	apiextv1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
)

//go:generate go run generate.go
func main() {
	log.Printf("starting generate")

	crdGenerator := NewCRDGenerator(
		[]string{
			// gateway.solo.io CRDs
			"gateway.yaml",
			// "virtual_service.yaml",
			// "route_table.yaml",

			// TODO (sam-heilbron)
			// gloo.solo.io CRDs
			// "upstream.yaml",
			// "upstream_group.yaml",
			// "settings.yaml",
			// "proxy.yaml",

			// enterprise.gloo.solo.io
			// "auth_config.yaml",

			// ratelimit.solo.io
			// "ratelimit_config.yaml",
		},
		"100-crds.yaml")
	validationSchemaOptions, err := crdGenerator.GetValidationSchemaOptions()
	if err != nil {
		log.Fatalf("could not get crd validation schema options! :%v", err)
	}

	protoImports := sk_anyvendor.CreateDefaultMatchOptions(
		[]string{"projects/**/*.proto", sk_anyvendor.SoloKitMatchPattern},
	)
	protoImports.External["github.com/solo-io/solo-apis"] = []string{
		"api/rate-limiter/**/*.proto", // Import rate limit API
		"api/gloo-fed/fed/**/*.proto", // Import gloo fed gloo instance API
	}
	// Import gloo instance API dependencies
	protoImports.External["github.com/solo-io/skv2"] = []string{
		"api/**/**/*.proto",
	}

	generateOptions := cmd.GenerateOptions{
		SkipGenMocks: true,
		CustomCompileProtos: []string{
			"github.com/solo-io/gloo/projects/gloo/api/grpc",
		},
		SkipGeneratedTests: true,
		// helps to cut down on time spent searching for imports, not strictly necessary
		SkipDirs: []string{
			"docs",
			"test",
			"projects/gloo/api/grpc",
		},
		RelativeRoot:  ".",
		CompileProtos: true,
		GenDocs: &cmd.DocsOptions{
			Output: options.Hugo,
			HugoOptions: &options.HugoOptions{
				DataDir: "/docs/data",
				ApiDir:  "reference/api",
			},
		},
		ExternalImports:      protoImports,
		ValidationSchemaOpts: validationSchemaOptions,
	}

	if err := cmd.Generate(generateOptions); err != nil {
		log.Fatalf("generate failed!: %v", err)
	}

	if err := crdGenerator.GenerateCRDs(); err != nil {
		log.Fatalf("crd generate failed! :%v", err)
	}

	log.Printf("finished generating code")
}

const helm2CrdDirectory = "./install/helm/gloo/crds"
const helm3CrdDirectory = "./install/helm/gloo/templates"
const fileHeader = `// Code generated by solo-kit. DO NOT EDIT.

`

func NewCRDGenerator(helm2CrdFilenames []string, helm3CrdFilename string) *CRDGenerator {
	return &CRDGenerator{
		helm2CrdDirectory:    helm2CrdDirectory,
		helm2CrdFilenames:    helm2CrdFilenames,
		helm3CrdDirectory:    helm3CrdDirectory,
		helm3CrdFilename:     helm3CrdFilename,
		crdsWithSchemaByFile: make(map[string]apiextv1beta1.CustomResourceDefinition, len(helm2CrdFilenames)),
	}
}

// TODO (sam-heilbron)
// Until this feature is validated, write to a temp file location
func tempFileName(filename string) string {
	fileExt := filepath.Ext(filename)
	return fmt.Sprintf("%s.gen%s", strings.TrimSuffix(filename, fileExt), fileExt)
}

type CRDGenerator struct {
	helm2CrdDirectory string
	helm2CrdFilenames []string

	helm3CrdDirectory string
	helm3CrdFilename  string

	crdsWithSchemaByFile map[string]apiextv1beta1.CustomResourceDefinition
}

func (g *CRDGenerator) GetValidationSchemaOptions() (*schemagen.ValidationSchemaOptions, error) {
	var schemaOptions []*v1beta1.SchemaOptions

	for _, fileName := range g.helm2CrdFilenames {
		// Ensure that OnSchemaComplete closure is called with the appropriate file name
		crdFileName := fileName

		crd, err := v1beta1.GetCRDFromFile(filepath.Join(g.helm2CrdDirectory, crdFileName))
		if err != nil {
			return nil, err
		}

		schemaOptions = append(schemaOptions, &v1beta1.SchemaOptions{
			OriginalCrd: crd,
			OnSchemaComplete: func(crdWithSchema apiextv1beta1.CustomResourceDefinition) error {
				g.crdsWithSchemaByFile[crdFileName] = crdWithSchema
				return nil
			},
		})
	}

	return &schemagen.ValidationSchemaOptions{
		SchemaOptions: schemaOptions,
	}, nil
}

func (g *CRDGenerator) GenerateCRDs() error {
	if len(g.crdsWithSchemaByFile) == 0 {
		return eris.New("Cannot call GenerateCRDs with 0 CRDs")
	}

	if err := g.writeHelm2CRDs(); err != nil {
		return err
	}
	return g.writeHelm3CRDs()
}

func (g *CRDGenerator) writeHelm2CRDs() error {
	crdWriter := writer.DefaultFileWriter{
		Root:   g.helm2CrdDirectory,
		Header: fileHeader,
	}

	var crdFiles code_generator.Files
	for _, fileName := range g.helm2CrdFilenames {
		crdWithSchema, ok := g.crdsWithSchemaByFile[fileName]
		if !ok {
			return eris.Errorf("Could not find crd for file: %s", fileName)
		}

		fileBytes, err := yaml.Marshal(crdWithSchema)
		if err != nil {
			return err
		}

		crdFiles = append(crdFiles, code_generator.File{
			Filename: tempFileName(fileName), // TODO (sam-heilbron)
			Content:  string(fileBytes),
		})
	}
	return crdWriter.WriteFiles(crdFiles)
}

func (g *CRDGenerator) writeHelm3CRDs() error {
	crdWriter := writer.DefaultFileWriter{
		Root:   g.helm3CrdDirectory,
		Header: fileHeader,
	}

	var manifests []string
	// To ensure that we create the crds in a consistent order, iterate
	// over the helm2 file names
	for _, fileName := range g.helm2CrdFilenames {
		crdWithSchema, ok := g.crdsWithSchemaByFile[fileName]
		if !ok {
			return eris.Errorf("Could not find crd for file: %s", fileName)
		}

		fileBytes, err := yaml.Marshal(crdWithSchema)
		if err != nil {
			return err
		}
		manifests = append(manifests, string(fileBytes))
	}

	fileContent := fmt.Sprintf(
		"%s%s%s",
		"{{- if .Values.crds.create }}\n",
		strings.Join(manifests, "---\n"),
		"---\n{{- end}}")

	helm3CrdFile := code_generator.File{
		Filename: tempFileName(g.helm3CrdFilename), // TODO (sam-heilbron)
		Content:  fileContent,
	}
	return crdWriter.WriteFile(helm3CrdFile)
}
